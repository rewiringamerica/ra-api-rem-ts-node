/**
 * Residential Electrification Model API
 * An API for REM, the Residential Electrification Model.
 *
 * The version of the OpenAPI document: 0.4.6
 * Contact: datascience@rewiringamerica.org
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import localVarRequest from 'request';
import http from 'http';


import { HTTPValidationError } from '../model/hTTPValidationError';
import { HeatingFuel } from '../model/heatingFuel';
import { RemProfileRequest } from '../model/remProfileRequest';
import { Savings } from '../model/savings';
import { SupportedUpgrade } from '../model/supportedUpgrade';

import { ObjectSerializer, Authentication, VoidAuth, Interceptor } from '../model/models';
import { HttpBearerAuth } from '../model/models';

import { HttpError } from './apis';

let defaultBasePath = 'https://api.rewiringamerica.org';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

export enum ResidentialElectrificationModelApiApiKeys {
}

export class ResidentialElectrificationModelApi {
    protected _basePath = defaultBasePath;
    protected _defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'auth': new HttpBearerAuth(),
    }

    protected interceptors: Interceptor[] = [];

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    set defaultHeaders(defaultHeaders: any) {
        this._defaultHeaders = defaultHeaders;
    }

    get defaultHeaders() {
        return this._defaultHeaders;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
        this.authentications.default = auth;
    }

    public setApiKey(key: ResidentialElectrificationModelApiApiKeys, value: string) {
        (this.authentications as any)[ResidentialElectrificationModelApiApiKeys[key]].apiKey = value;
    }

    set accessToken(accessToken: string | (() => string)) {
        this.authentications.auth.accessToken = accessToken;
    }

    public addInterceptor(interceptor: Interceptor) {
        this.interceptors.push(interceptor);
    }

    /**
     * Predict a user\'s annual savings using the Residential Electrification Model. This API makes predictions of the energy, emissions, and energy bill changes for an existing home based on the upgrade type, the address of the home being upgraded, and the current heating fuel.  Using the provided address, we first query a large database of home properties that Rewiring America has assembled, which contains data such as home age, size, construction material, and much more. We don\'t know all of the properties needed to get a good estimate of energy consumption, so we perform a [Monte Carlo](https://en.wikipedia.org/wiki/Monte_Carlo_method) simulation over a sample homes chosen from a [conditional probability distribution](https://github.com/NREL/resstock/tree/develop/project_national/housing_characteristics) based the properties that we do know. We then estimate the energy consumption for each sample building by running inference using a Machine Learning based surrogate model, trained on [EnergyPlus](https://energyplus.net/) simulations.  The response JSON is a dictionary with three components: - `fuel_results`: This is a dictionary of the main results from the model, one for each fuel type: `electricity`, `fuel_oil`, `natural_gas`, `propane`, `total` (for the total of all the others). - `rates`: A summary of the rates used to calculate the annual cost in dollars for each fuel. These vary from region to region based local fuel costs. - `emissions_factors`: A summary of the local emissions factors used to calculate annual emissions. Electricity emissions vary from region to region based on how electricity is generated.  Within the `fuel_results` subsection for each of the fuel types, there are three components:   - `baseline`: the annual usage of the fuel before the upgrade across all end uses  (e.g., heating, cooling, water heating, drying, cooking).   - `upgrade`: the annual usage of the fuel after the upgrade across all end uses.   - `delta`: the change in usage of the fuel across all end uses.  Inside those three, there are parallel structures with statistics for the `energy` consumption for each fuel, as well as the `emissions` and `cost` incurred by the consumption of each fuel. The electricity emissions factors are [long run marginal emissions rates assuming a 95% decarbonized grid by 2050](https://www.nrel.gov/analysis/cambium.html).  The emissions and costs are computed with the `rates` and `emissions_factors` data mentioned above, where the costs reflect the annual costs from both volumetric charges and fixed charges. Note that the fixed charges are based on the presence of the given fuel in the baseline scenario, and not assumed to change in the upgrade scenario.  All of the statistics are for a full typical weather year. The units for each of the statistics are also provided and are as appropriate for the fuel, emissions, or cost.  If `baseline` is specified as the upgrade in the request, `fuel_results` will exclude `upgrade` and `delta` since baseline represents the home\'s current state without any upgrades.  **A note on statistics**: For each value we provide statistics for, we provide a mean, a median, and the 20th and 80th percentile values over all the set of sample homes in the Monte Carlo simulation. It is important to note that the statistics are taken over the distribution of the values they represent. This means, for example, that the median electricity usage before the upgrade, the median electricity usage after the upgrade, and the median change of electricity usage might all be from the same modeled home. So adding the median change to the median usage before the upgrade might not produce the number reported as the median usage after the upgrade.  Note that because we are modeling whole home energy consumption over a set of building samples, and the building set contains homes with a variety of fuels for the non-heating appliances, you may see consumption of fuels other than the passed heating fuel, particularly for the mean.  **Demonstrations**  There are two sample Python notebooks that demonstrate the API in action. - [REM Demo.ipynb](https://github.com/rewiringamerica/api_demos/blob/main/notebooks/REM%20Demo.ipynb) illustrates basic API calls. - [All About REM Statistics.ipynb](https://github.com/rewiringamerica/api_demos/blob/main/notebooks/All%20About%20REM%20Statistics.ipynb) digs into details on the statistics that the API returns and how they relate to one another in various circumstances.  There are also examples showing how to integrate the REM API into a web site. See the full list [here](https://github.com/rewiringamerica/api_demos?tab=readme-ov-file#api_demos).
     * @summary Get by address
     * @param upgrade The upgrade whose effects we want to analyze. Supported values are as follows: - &#x60;baseline&#x60;: Baseline building with no upgrades applied. - &#x60;combination__all_electric__hvac_seer24_hspf13__weatherization&#x60;: A whole-home upgrade including a high efficiency air source heat pump for the home’s HVAC system, basic weatherization, a heat pump water heater, a heat pump dryer, and an induction stove. HVAC heat pump is SEER 24, HSPF 13 for ducted systems; SEER 29.3, HSPF 14 for ductless systems, heat pump water heater is UEF 3.35-3.45, and heat pump dryer is Combined Energy Factor (CEF) 5.2. Additional details can be found in measure package 9 (on page 9) of [this document](https://oedi-data-lake.s3.amazonaws.com/nrel-pds-building-stock/end-use-load-profiles-for-us-building-stock/2022/EUSS_ResRound1_Technical_Documentation.pdf).  - &#x60;combination__hvac_seer18_hspf10__weatherization&#x60;: A medium-efficiency heat pump upgrade for the home\&#39;s HVAC system, plus a basic weatherization upgrade. The heat pump is SEER 18, HSPF 10 for ducted systems; SEER 18, HSPF 10.5 for ductless systems. The nominal capacity is sized equal to the larger of heating/cooling design loads, and the heating and cooling are modeled without setpoint setbacks. The basic weatherization component of this upgrade includes attic floor insulation, air sealing, duct sealing, and drill-and-fill insulation. Attic floor insulation levels are upgraded for compliance with IECC-Residential 2021 and range from R-30 to R-60 depending on climate zone. Attic floor insulation only applies to dwelling units with vented attics. Air sealing is performed to reduce ACH50 by 30%, duct sealing is performed to reduce duct leakage to 10%, and a drill-and-fill insulation level of R-13 is applied to uninsulated wood stud walls. Additional details can be found in measure package 1 (on page 4) of [this document](https://oedi-data-lake.s3.amazonaws.com/nrel-pds-building-stock/end-use-load-profiles-for-us-building-stock/2022/EUSS_ResRound1_Technical_Documentation.pdf). - &#x60;hvac__heat_pump_seer15_hspf9&#x60;: A relatively-low efficiency air source heat pump upgrade for the home’s HVAC system. Heat pump is SEER 15, HSPF 9 for both ducted and ductless systems.Additional details can be found in measure package 3 (on page 5) of [this document](https://oedi-data-lake.s3.amazonaws.com/nrel-pds-building-stock/end-use-load-profiles-for-us-building-stock/2022/EUSS_ResRound1_Technical_Documentation.pdf). - &#x60;hvac__heat_pump_seer18_hspf10&#x60;: A medium-efficiency heat pump upgrade for the home\&#39;s HVAC system. SEER 18, HSPF 10 for ducted systems; SEER 18, HSPF 10.5 for ductless systems. The nominal capacity is sized equal to the larger of heating/cooling design loads, and the heating and cooling are modeled without setpoint setbacks.  - &#x60;hvac__heat_pump_seer24_hspf13&#x60;: A high efficiency air source heat pump upgrade for the home’s HVAC system. Heat pump is SEER 24, HSPF 13 for ducted systems; SEER 29.3, HSPF 14 for ductless systems. Additional details can be found in measure package 4 (on page 6) of [this document](https://oedi-data-lake.s3.amazonaws.com/nrel-pds-building-stock/end-use-load-profiles-for-us-building-stock/2022/EUSS_ResRound1_Technical_Documentation.pdf).  - &#x60;weatherization__insulation_air_duct_sealing&#x60;: A basic weatherization upgrade for the home. Measures include attic floor insulation, air sealing, duct sealing, and drill-and-fill insulation. Attic floor insulation levels are upgraded for compliance with IECC-Residential 2021 and range from R-30 to R-60 depending on climate zone. Attic floor insulation only applies to dwelling units with vented attics. Air sealing is performed to reduce ACH50 by 30%, duct sealing is performed to reduce duct leakage to 10%, and a drill-and-fill insulation level of R-13 is applied to uninsulated wood stud walls. Additional details can be found in measure package 1 (on page 4) of [this document](https://oedi-data-lake.s3.amazonaws.com/nrel-pds-building-stock/end-use-load-profiles-for-us-building-stock/2022/EUSS_ResRound1_Technical_Documentation.pdf).
     * @param address The full address for a location including street number and name, city, state, and zip code.
     * @param heatingFuel The heating fuel used in the home before the upgrade. Supported values are as follows: - &#x60;electricity&#x60;: the home is currently heated with electric heating, such as   electric resistance heating or a heat pump. - &#x60;natural_gas&#x60;: The home is currently heated with natural gas. - &#x60;fuel_oil&#x60;: The home is currently heated with fuel oil. - &#x60;propane&#x60;:  The home is currently heated with propane. 
     */
    public async getByAddress (upgrade: SupportedUpgrade, address: string, heatingFuel: HeatingFuel, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Savings;  }> {
        const localVarPath = this.basePath + '/api/v1/rem/address';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'upgrade' is not null or undefined
        if (upgrade === null || upgrade === undefined) {
            throw new Error('Required parameter upgrade was null or undefined when calling getByAddress.');
        }

        // verify required parameter 'address' is not null or undefined
        if (address === null || address === undefined) {
            throw new Error('Required parameter address was null or undefined when calling getByAddress.');
        }

        // verify required parameter 'heatingFuel' is not null or undefined
        if (heatingFuel === null || heatingFuel === undefined) {
            throw new Error('Required parameter heatingFuel was null or undefined when calling getByAddress.');
        }

        if (upgrade !== undefined) {
            localVarQueryParameters['upgrade'] = ObjectSerializer.serialize(upgrade, "SupportedUpgrade");
        }

        if (address !== undefined) {
            localVarQueryParameters['address'] = ObjectSerializer.serialize(address, "string");
        }

        if (heatingFuel !== undefined) {
            localVarQueryParameters['heating_fuel'] = ObjectSerializer.serialize(heatingFuel, "HeatingFuel");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.auth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.auth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Savings;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Savings");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Predict a user\'s annual savings using Residential Electrification Model, using a Building Profile and an Upgrade.
     * @summary Get by profile
     * @param remProfileRequest 
     */
    public async getByProfile (remProfileRequest: RemProfileRequest, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Savings;  }> {
        const localVarPath = this.basePath + '/api/v1/rem/profile';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'remProfileRequest' is not null or undefined
        if (remProfileRequest === null || remProfileRequest === undefined) {
            throw new Error('Required parameter remProfileRequest was null or undefined when calling getByProfile.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(remProfileRequest, "RemProfileRequest")
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.auth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.auth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Savings;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Savings");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Return the back end version of the code that is deployed.  This is not the version of the API, but rather of the code that implements it. This is mainly to track code deployments. The same API version is typically supported by a series of deployments each of which improves upon earlier ones in some way, such as fixing bugs or improving performance.
     * @summary Get implementation version
     */
    public async getImplVersion (options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: string;  }> {
        const localVarPath = this.basePath + '/api/v1/rem/server_version';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.auth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.auth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: string;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "string");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
}
